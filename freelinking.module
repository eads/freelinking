<?php
//$Id$
/**
 * Freelinking 3
 * Provides flexibe linking of content, wiki-style
 */

/**
 * Implementation of hook_menu()
 */
function freelinking_menu() {
  $items['admin/settings/freelinking'] = array(
    'title' => 'Freelinking settings',
    'description' => 'Configure settings for the freelinking input filter',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('freelinking_settings'),
    'access arguments' => array('administer freelinking'),
  );
  return $items;
} // endfunction freelinking_menu

/**
 * Implementation of hook_perm()
 */
function freelinking_perm() {
  return array('administer freelinking');
}

/**
 * Implementation of hook_perm()
 */
function freelinking_filter($op, $delta = 0, $format = -1,
  $text = '', $langcode = '', $cache_id = 0) {

  switch ($op) {
    case 'list':
      return array(0 => 'freelinking filter');
    case 'no cache':
//      return FALSE;
return TRUE;
    case 'description':
      return t('Allows for a flexible format for linking content');
    case 'process':
      $freelinking = freelinking_get_plugins();
      $defaultplugin = variable_get('freelinking_default', 'nodetitle');
      $markdown = variable_get('freelinking_markdown_mode', FALSE);

      // Loop through every freelink format
      // Space at text start prevents match failure at start.
      preg_match_all(_freelinking_match_pattern(), ' ' . $text,
        $matches, PREG_SET_ORDER);

      foreach($matches as $match) {
        $current_plugin = '';

        // do not strip away first character of match
        $match[0] = preg_replace('/^[^\\\\]/', '', $match[0]);

        // in markdown mode, the first match is part of the target.
        if ($markdown) {
          $match[1] .= '|' . $match[2];
        }

        // default freelink (no colon)
        if(strpos($match[1], ':') === FALSE) {
          $current_plugin = $defaultplugin;
          $target = $match[1];
        } // end default freelink
        else {
          list($indicator, $target) = explode(':', $match[1]);
          // find a plugin for the match
          foreach(array_keys($freelinking) as $plugin) {
            if(preg_match($freelinking[$plugin]['indicator'], $indicator)) {
              $current_plugin = $plugin;
            }
          }// end looping through plugins
        } // end non-default freelinks
        $link = _freelinking_build_freelink($freelinking, $current_plugin,
          $target);
        $text = str_replace($match[0], $link, $text);
      }
      return $text;
    case 'prepare':
    default:
      return $text;
  } // endswitch $op
} // endfunction freelinking_filter

/**
 * Implementation of hook_freelinking()
 * Include plugins/*.inc plugins
 */
function freelinking_freelinking() {
  $files = file_scan_directory(
    drupal_get_path('module', 'freelinking') . '/plugins/', '.inc');
  foreach($files as $absolute => $file) {
    require $absolute;
  }
  foreach ($freelinking as $plugin => $definition)
  {
    if(!$definition['settings']) {
      $freelinking[$plugin]['settings'] = 'freelinking_' . $plugin . '_settings';
    }
  }
  return $freelinking;
}

/**
 * Construct a link out of the $target with the specified plugin
 */
function _freelinking_build_freelink($freelinking, $plugin_name, $target) {
  // by default return false so no replacement happens
  $target = freelinking_parse_target($target);
  $plugin = $freelinking[$plugin_name];

  // run the text through translation
  if ($plugin['translate']) {
    $target['dest'] = strtr($target['dest'], $plugin['translate']);
  }

  // process simple replacement plugins
  if ($plugin['replacement']) {
    // %1 is the token all freelinking replacement strings must include
    $url = preg_replace('/%1/', $target['dest'], $plugin['replacement']);
    $title = $target['text'] ? $target['text'] : $target['dest'];
    $link = array(ucfirst($title), $url);
  }
  // process replacement callback
  // arguments to callbacks consistent from use of preg_replace_callback
  if (function_exists($plugin['callback'])) {
    $link = call_user_func_array($plugin['callback'],
      array($target));
  }
  // Standardize link, grab authoritative "structured" version
  // designate the rendered text for display
  if (is_array($link)) {
    drupal_alter('freelink', $link, $target, $plugin, $plugin_name);
    if(is_array($link)) {
      $url = $link[1];
      $rendered = call_user_func_array('l', $link);
    }
    else {
      $rendered = $link;
    }
  }

  // if they are "normal" freelinks add to the unique links list.
  if ($plugin['unique link'] !== FALSE && $url) {
    freelinking_set_link(array($url,
      array('link' => $rendered, 'plugin' => $plugin_name)),
        strcasecmp($plugin['unique link'], 'override') == 0);
  }
  // if callback does not exist do not replace
  return $rendered;
}

/**
 * Parse target for secondary link arguments.
 * This is raw user input and needs to be checked by the HTML Filter.
 */
function freelinking_parse_target($target, $separator = NULL) {
  if (!$separator) {
    $separator = '|';
  }
  $args = array();
  $args['target'] = $target;
  list($args['dest'], $args['text'], $args['tooltip'], $other) = explode('|', $target);
  return $args;
}

/**
 * Implementation of hook_freelink_alter()
 * Used here to clean up and standardize links.
 */
function freelinking_freelink_alter(&$link, $target, $plugin, $plugin_name) {
  // not a valid link
  if (!$link[1]) {
    $link = '<span class="freelink error">[' . t('Invalid Link') . ']</span>';
  }

  // title text is empty, insert some
  if (!$link[0]) {
    $link[0] = $target['text'] ? $target['text'] : $target['dest'];
  }

  // support html link text unless plugin overrides
  if ($plugin['html'] !== FALSE) {
    $link[2]['html'] = TRUE;
  }

  // Set an empty tooltip as the URL (unless the target has one)
  if (!$link[2]['attributes']['title']) {
    $link[2]['attributes']['title'] =
      $target['tooltip'] ? $target['tooltip'] : $link[1];
  }

  // standard set of CSS classes
  $link[2]['attributes']['class'] = rtrim('freelink freelink-'
    . strtr($plugin_name, ' ', '-') . ' ' . $link[2]['attributes']['class']);
}

/**
 * Build admin/settings page.
 */
function freelinking_settings() {
  $form = array();

  foreach(freelinking_get_plugins() as $plugin => $definition) {
    $available_plugins[$plugin] = ucfirst($plugin);
    if (function_exists($definition['settings'])) {
      $plugin_with_settings[$plugin] = $definition['settings'];
    }
  }

  // set the default plugin
  $form['freelinking_default'] = array(
    '#title' => t('Plugin to use when not indicated in the freelink'),
    '#type'  => 'select',
    '#multiple' => FALSE,
    '#options' => $available_plugins,
    '#default_value' => variable_get('freelinking_default', 'nodetitle'),
    '#description' => t('Default plugin to use when not specified in text. "Nodetitle" mimics previous versions of Freelinking.'),
  );

  $form['freelinking_markdown_mode'] = array(
    '#title' => t('Markdown Syntax Mode'),
    '#type' => 'checkbox',
    '#default_value' => variable_get('freelinking_markdown_mode', FALSE),
    '#description' => t('Use Markdown syntax [Title](plugin:url) in place of Freelinking syntax [[plugin:url|Title]]'),
  );

  // loop through plugin settings functions, adding a fieldset for each
  foreach ($plugin_with_settings as $plugin=>$callback) {
    $form[$plugin] = array(
      '#title' => t('Settings for !plugin plugin', array('!plugin' => ucfirst($plugin))),
      '#type'  => 'fieldset',
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
     );
    $form[$plugin]['settings'] = call_user_func($callback);
  } // endforeach looping through plugins with settings

  return system_settings_form($form);
} // endfunction freelinking_settings (admin settings)

/**
 * Freelinking API
 */

/**
 * Invoke hook_freelinking() once per page load.
 */
function freelinking_get_plugins() {
  static $freelinking;
  if($freelinking) {
    return $freelinking;
  }
  $freelinking = module_invoke_all('freelinking');
  return $freelinking;
}

/**
 * Get the current set of unique links.
 * Takes a string or array as argument.
 * Will exclude plugins not specified.
 * "TRUE" will get you an array of just links.
 * NULL will get you everything.
 */
function freelinking_get_links($plugin = NULL) {
  $links = freelinking_set_link();

  if ($plugin && $links) {
    if (!is_array($plugin)) {
      $plugin = array($plugin);
    }
    foreach($links as $link) {
      if (in_array($link['plugin'], $plugin) || $plugin[0] === TRUE) {
        $processed[] = $link['link'];
      }
    }
    $links = $processed;
  }
  return $links;
}

/**
 * If sent a link, process it for the unique links array.
 * If not sent anything, return the current set of links.
 * link format:
 *  '<url>' => array('link' => <link>, 'plugin' => <plugin name>)
 */
function freelinking_set_link($link = NULL, $override = FALSE) {
  static $links;

  if(!$link) {
    if(empty($links)) {
      return;
    }
    return $links;
  }
  $index = check_plain($link[0]);
  // index on destination (url) of the link
  // if a link already exists and the new link is not overriding, skip.
  if(!$links[$index] || $override) {
    $links[$index] = $link[1];
  }
}

function freelinking_short_url($url) {
  if($url['host']) {
   return '"' . ucfirst(basename($url['path'])) . '" on ' . $url['host'];
  }
  return $url['path'];
}

/**
 * Helper Functions
 */

/**
 * Collect freelink format patterns for filtering.
 */
function _freelinking_match_pattern($separator = NULL) {
  if (!$separator) {
    $separator = ':';
  }
  $separator = preg_quote($separator);

  // Markdown mode: use inline markdown link syntax
  if (variable_get('freelinking_markdown_mode', FALSE)) {
    return '/[^\\\\]\[([^\[.]*)\]\((.+' . $separator . '.+)\)/Uu';
  }
  // Otherwise, use freelink/wiki style
  return '/[^\\\\]\[\[(.+' . $separator . '?.+)]]/Uu';
}

// vim: tw=300 nowrap syn=php
