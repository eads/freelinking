<?php
// freelinking3 -- flexible linking of content

function freelinking_filter($op, $delta = 0, $format = -1,
  $text = '', $langcode = '', $cache_id = 0) {

  switch ($op) {
    case 'list':
      return array(0 => 'freelinking filter');
    case 'no cache':
      return FALSE;
    case 'description':
      return t('Allows for a flexible format for linking content');
    case 'process':
      $freelinking = _freelinking_get_plugins();
      $freelink_patterns = _freelinking_regex_patterns();
      $defaultplugin = variable_get('freelinking_default', 'nodetitle');

      // Loop through every freelink format
      foreach($freelink_patterns as $regex) {
        $current_plugin = '';
        preg_match_all($regex['pattern'], $text, $matches, PREG_SET_ORDER);
        foreach($matches as $match) {
          // default freelink (no colon)
          if(strpos($match[1], ':') === FALSE) {
            $current_plugin = $defaultplugin;
            $target = $match[1];
          } // end default freelink
          else {
            list($indicator, $target) = explode(':', $match[1]);
            // find a plugin for the match
            foreach(array_keys($freelinking) as $plugin) {
              if(preg_match($freelinking[$plugin]['indicator'], $indicator)) {
                $current_plugin = $plugin;
              }
            }// end looping through plugins
          } // end non-default freelinks
          $link = freelinking_build_freelink($freelinking[$current_plugin],
            $target, $regex['mode']);
          if (!$regex['mode']) {
            $text = str_replace($match[0], ' ' . $link, $text);
          }
          else {
            $text = str_replace($match[1], ' ' . $link, $text);
          }
        } // end looping through matches
      } // end looping through freelink formats
      return $text;
    case 'prepare':
    default:
      return $text;
  } // endswitch $op
} // endfunction freelinking_filter

function freelinking_menu() {
  $items['admin/settings/freelinking'] = array(
    'title' => 'Freelinking settings',
    'description' => 'Configure settings for the freelinking input filter',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('freelinking_settings'),
    'access arguments' => array('administer freelinking'),
  );
  return $items;
} // endfunction freelinking_menu

function freelinking_settings() {
  $form = array();

  foreach(_freelinking_get_plugins() as $plugin => $definition) {
    $available_plugins[$plugin] = $plugin;
    if (function_exists($definition['settings'])) {
      $plugin_with_settings[$plugin] = $definition['settings'];
    }
  }

  // set the default plugin
  $form['freelinking_default'] = array(
    '#title' => t('Plugin to use when not indicated in the freelink'),
    '#type'  => 'select',
    '#multiple' => FALSE,
    '#options' => $available_plugins,
    '#default_value' => variable_get('freelinking_default', 'nodetitle'),
    '#description' => t('Use this plugin when a freelink is created without specifying which plugin to use. If unsure, "nodetitle" mimics the behavior of previous versions of freelinking.'),
  );

  // loop through plugin settings functions, adding a fieldset for each
  foreach ($plugin_with_settings as $plugin=>$callback) {
    $form[$plugin] = array(
      '#title' => t('Settings for !plugin plugin', array('!plugin' => ucfirst($plugin))),
      '#type'  => 'fieldset',
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
     );
    $form[$plugin]['settings'] = call_user_func($callback);
  } // endforeach looping through plugins with settings

  return system_settings_form($form);
} // endfunction freelinking_settings (admin settings)

/**
 * Implementation of hook_freelinking()
 * Include .inc plugins
 */
function freelinking_freelinking() {
  $files = file_scan_directory(
    drupal_get_path('module', 'freelinking') . '/plugins/', '.inc');
  foreach($files as $absolute => $file) {
    require $absolute;
  }
  foreach ($freelinking as $plugin => $definition)
  {
    if(!$definition['settings']) {
      $freelinking[$plugin]['settings'] = 'freelinking_' . $plugin . '_settings';
    }
  }
  return $freelinking;
}

/**
 * module_invoke_all once per pageload. May be unnecessary.
 */
function _freelinking_get_plugins() {
  static $freelinking;
  if($freelinking) {
    return $freelinking;
  }
  $freelinking = module_invoke_all('freelinking');
  return $freelinking;
}

/**
 * Construct a link out of the $target by the plugin definition
 */
function freelinking_build_freelink($plugin, $target, $mode = NULL) {
  // by default return false so no replacement happens
  $link = FALSE;

  $target = freelinking_parse_target($target);
  // run the text through translation
  if ($plugin['translate']) {
    $target[1] = strtr($target[1], $plugin['translate']);
  }

  // process simple replacement plugins
  if ($plugin['replacement']) {
    // %1 is the token all freelinking replacement strings must include
    $t_url = preg_replace('/%1/', $target[1], $plugin['replacement']);
    $tooltip = $target[2] ? $target[2] : $t_url;
    if(!$mode) {
      $link = l($target[0], $t_url,
        array('class' => 'freelink ' . $plugin, 'title' => $tooltip));
    }
    else {
      $link = $t_url;
    }
  }
  // process replacement callback
  // arguments to callbacks consistent from use of preg_replace_callback
  if (function_exists($plugin['callback'])) {
    $link =  calL_user_func_array($plugin['callback'],
      array($target));

    if (!$mode && is_array($link)) {
      $link = call_user_func_array('l', $link);
    }
    else if ($mode) {
      $link = is_array($link) ? $link[1] : FALSE;
    }
  }

  // if callback does not exist do not replace
  return $link;
}

/**
 * Parse target for secondary link arguments.
 * This is raw user input and needs to be checked by the HTML Filter.
 */
function freelinking_parse_target($target, $separator = NULL) {
  if (!$separator) {
    $separator = '|';
  }
  $args = array();
  $args[0] = $target;
  $args = array_merge($args, explode('|', $target));
  return $args;
}


/**
 * Collect freelink format patterns for filtering.
 */
function _freelinking_regex_patterns($separator = NULL) {
  if (!$separator) {
    $separator = ':';
  }
  $separator = preg_quote($separator);
  $regex = array();

  // standard freelink syntax
  $regex[] = array(
    'pattern' => '/[^\\\\]\[\[(.+' . $separator . '?.+)]]/Uu',
  );

  // markdown support
  if (module_exists('markdown')) {
    $regex[] = array(
      'pattern' => '/[^\\\\]\[.+\]\((.+' . $separator . '.+)\)/Uu',
      'mode' => 'url',
    );
    $regex[] = array(
      'pattern' => '/\n[^\\\\]\s\s+\[.+\]' . $separator . '\s+(.+:.+)\n/Uu',
      'mode' => 'url',
    );
  }

  return $regex;
}

// vim: tw=300 nowrap syn=php
